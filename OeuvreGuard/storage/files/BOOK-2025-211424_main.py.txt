# app/main.py
from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.responses import FileResponse
import os, uuid
from sqlalchemy.orm import Session
from .db import get_db, engine
from .models import Oeuvre, Empreinte
from . import processing, embeddings_index, report_utils
from .utils import save_upload_file, make_uid
from .models import Base

Base.metadata.create_all(bind=engine)

app = FastAPI()
"""UPLOAD_DIR = os.getenv("UPLOAD_DIR", "/data/uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)"""

def get_conn():
    return psycopg2.connect(
        dbname="oeuvre_guard_db",
        user="postgres",
        password="qwerty123456",
        host="localhost",  
        port="5434"        
    )

# load faiss index if exists
INDEX, EMBS, METAS = embeddings_index.load_index()  # may be None

@app.post("/upload_and_check")
async def upload_and_check(file: UploadFile = File(...), titre: str = Form(None), auteur: str = Form(None)):
    # save
    titre = make_uid()
    filename = f"{uid}_{file.filename}"
    filepath = os.path.join(UPLOAD_DIR, filename)
    save_upload_file(file, filepath)

    # decide type
    ext = os.path.splitext(filename)[1].lower()
    if ext in [".mp3", ".wav", ".flac", ".ogg"]:
        # audio pipeline
        fp = processing.compute_audio_fingerprint(filepath)
        emb = processing.compute_audio_embedding(filepath)
        candidates = []
        if INDEX is not None:
            D, I = processing.search_faiss_index(INDEX, emb, k=10)
            for score, idx in zip(D, I):
                if idx == -1:
                    continue
                candidates.append({"meta": METAS[idx], "score": float(score)})
        # for each top candidate we should fetch file path from DB and run audio_dtw_segments
        segments = []
        # For brevity, not fetching DB files here. In production: query DB for METAS[idx] filepath.
        metadata = {"uid": uid, "titre": titre or "", "auteur": auteur or "", "type": "audio"}
        report_path = f"storage/reports/{uid}.pdf"
        report_utils.generate_pdf_report(report_path, metadata, [str(c) for c in candidates], segments)
        return {"uid": uid, "fingerprint": fp, "candidates": candidates, "report": report_path}

    else:
        # text pipeline
        text = processing.extract_text(filepath)
        simhash_val = processing.compute_simhash(text)
        emb = processing.compute_text_embedding(text)
        candidates = []
        if INDEX is not None:
            D, I = processing.search_faiss_index(INDEX, emb, k=10)
            for score, idx in zip(D, I):
                if idx == -1:
                    continue
                candidates.append({"meta": METAS[idx], "score": float(score)})
        # For each candidate, fetch DB text and run sentence_align (not shown here)
        segments = []
        metadata = {"uid": uid, "titre": titre or "", "auteur": auteur or "", "type": "texte"}
        report_path = f"storage/reports/{uid}.pdf"
        report_utils.generate_pdf_report(report_path, metadata, [str(c) for c in candidates], segments)
        return {"uid": uid, "simhash": simhash_val, "candidates": candidates, "report": report_path}

@app.get("/report/{uid}")
def get_report(uid: str):
    path = f"storage/reports/{uid}.pdf"
    if not os.path.exists(path):
        raise HTTPException(status_code=404, detail="Report not found")
    return FileResponse(path, media_type="application/pdf", filename=f"{uid}.pdf")
